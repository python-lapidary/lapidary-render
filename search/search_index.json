{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#synopsis","title":"Synopsis","text":"<p>Lapidary-render is a code generator that creates client code from an OpenAPI document.</p>"},{"location":"#project-goals","title":"Project Goals","text":"<ul> <li> <p> Deliver IDE-friendly client code that simplifies communication with API servers.</p> </li> <li> <p> The generator code should be simple.</p> <p>Generator processes data in three stages</p> <ol> <li>Enhance and transform OpenAPI to a structure more close resembling python model structure</li> <li>Convert the enhanced OpenAPI to a metamodel</li> <li>Convert the metamodel to a syntax tree</li> </ol> </li> <li> <p> Client code should be simple.</p> <p>The generated code uses the <code>lapidary</code> DSL library, which makes the client code DRY and similar in style to API servers that use Litestar or FastAPI.</p> </li> <li> <p> Compatible changes to the OpenAPI document should result in compatible changes to the generated code.</p> <p>Whenever possible, generated names should not depend on elements position, or the presence or absence of other elements.</p> <p>Starting from version 1.0; terms and conditions apply.</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>I recommend installing via <code>pipx</code>:</p> <p><code>pipx install lapidary-render</code></p> <p>Note that lapidary-render requires Python 3.13</p>"},{"location":"#usage","title":"Usage","text":"<p>The <code>lapidary</code> command offers inline help and shell command completion. See <code>lapidary --help</code> for details.</p>"},{"location":"#lapidary-init","title":"<code>lapidary init</code>","text":"<p><code>lapidary init [--save] SCHEMA_PATH PROJECT_ROOT PACKAGE_NAME</code></p> <p>Initializes a project directory with a <code>pyproject.toml</code> file and optionally stores the OpenAPI document.</p>"},{"location":"#lapidary-render","title":"<code>lapidary render</code>","text":"<p><code>lapidary render [PROJECT_ROOT]</code></p> <p>Renders the client code in the project root. The default project root is the current directory.</p> <p>All python files are generated in the <code>PROJECT_ROOT/src</code> directory.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>Lapidary can be configured with a <code>pyproject.yaml</code> file of the client project, under <code>[tool.lapidary]</code> key.</p> <p>package : root package name.</p> <p>document_path : path of the OpenAPI document, relative to the project root.</p> <p>origin : URL of the OpenAPI document, used when document_path is missing, or when <code>servers</code> is not defined, or the first server URL is a relative path.</p> <p>At least one of <code>document_path</code> and <code>origin</code> is required. Saving OpenAPI document in the project is recommended for repeatable builds.</p>"},{"location":"#extra-python-files","title":"Extra python files","text":"<p>Any additional python files can be put in a sub-package <code>extras</code> (${project_root}/src/${package}/extras).</p>"},{"location":"json-schema/","title":"JSONSchema","text":""},{"location":"json-schema/#json-schema","title":"JSON Schema","text":"<p>Representing JSON Schema as python types, aiming at producing types that can express no less values than the corresponding schema can validate. Another goal is to keep models as backwards compatible as much as possible, when the schema changes in a compatible way.</p> <p>The examples below use YAML notation of JSON Schema version draft-wright-json-schema-00.</p> <p>Python examples use python 3.10 (PEP 604) type hints syntax.</p>"},{"location":"json-schema/#set-theory","title":"Set theory","text":"<p>JSON is a data format representing a limited collection of basic data types.</p> <p>JSON Schema is language representing a set of constraints applicable to JSON, where empty schema means any JSON value, and set theory can be used to manipulate it.</p> <p>Python model types, while able to represent the same basic types as JSON, describe what can be stored in memory, where empty model represents no data, which is the inversion of how JSON Schema describes values.</p> <p>Note</p> <p>By default, object instances in python are just dictionaries with OOP syntax, but IDEs and type checking tools treat them more akin to C structs - if a field is not declared, it's not there.</p> <p>Simplified, JSON Schemas can be transformed to python model with the following formula</p> <p><code>python model = any JSON type - declared JSON Schema constraints</code></p>"},{"location":"json-schema/#type","title":"<code>type</code>","text":"<ol> <li> <p>Since Schema object validates any JSON value, let's consider it a Union type:</p> <pre><code>{}\n</code></pre> <p>=&gt;</p> <pre><code>dict | list | float | int | str | bool\n</code></pre> </li> <li> <p>pydantic provides type <code>JsonValue</code> type that reflects the type of any JSON data, except it also includes None for compatibility with JSON Schema.</p> </li> </ol>"},{"location":"json-schema/#type-specific-constraints","title":"Type-specific constraints","text":"<p>Most of the constraints are type-specific (they apply only to values of a single type).</p> <p>The exceptions are:</p> <ul> <li>nullable: extend types by type <code>null</code>, but only if type is specified in that schema</li> <li>enum: only allow values specified in the list</li> <li>numeric constraints for types <code>number</code> and <code>integer</code>, to both of which the numeric constraints apply.</li> </ul> <p>That means most constraints can be processed separately, which is useful when they occur together with <code>allOf</code>, <code>oneOf</code>, <code>allOf</code> and <code>not</code>.</p>"},{"location":"json-schema/#nullable","title":"nullable","text":"<ol> <li> <p>When <code>type</code> is present and <code>nullable</code> is <code>true</code>, the allowed types are extended with <code>null</code>. Three cases are possible</p> <ol> <li> <p>any type but null</p> <pre><code>{}\n</code></pre> </li> <li> <p>single type</p> <pre><code>type: integer\n</code></pre> <p>=&gt;</p> <pre><code>int\n</code></pre> </li> <li> <p>single type or null</p> <pre><code>type: integer\nnullable: true\n</code></pre> <p>=&gt;</p> <pre><code>int | None\n</code></pre> </li> </ol> </li> <li> <p>Any combination of types is possible with <code>anyOf</code>/<code>oneOf</code>.</p> <pre><code>anyOf:\n-   type: string\n-   type: integer\n    nullable: true\n</code></pre> <p>=&gt;</p> <pre><code>str | int | None\n</code></pre> </li> </ol>"},{"location":"json-schema/#enum","title":"<code>enum</code>","text":"<ol> <li> <p>If <code>enum</code> is in <code>anyOf</code> sub-schemas, the values are summed as sets.</p> </li> <li> <p>If <code>enum</code> is in <code>oneOf</code> sub-schemas, only the values that occur once can be validated     (not implemented, since Lapidary treats as just another anyOf).</p> </li> </ol>"},{"location":"json-schema/#enum-as-literal","title":"<code>enum</code> as <code>Literal</code>","text":"<ol> <li> <p>Scalar <code>enum</code> could be translated literally</p> <pre><code>enum:\n- true\n- false\n- FileNotFound\n</code></pre> <p>=&gt;</p> <pre><code>Literal[True, False, 'FileNotFound']\n</code></pre> <p>or grouped by type:</p> <pre><code>Union[\n    Literal[true, False],\n    StrLiteral['FileNotFound'],\n]\n</code></pre> </li> </ol>"},{"location":"json-schema/#enum-as-enumenum","title":"<code>enum</code> as <code>enum.Enum</code>","text":"<ol> <li> <p>Both scalar and non-scalar literals could be translated as python enums, but that would require names</p> <pre><code>type: object\nenum:\n- key: value\n</code></pre> <p>=&gt;</p> <pre><code>class ${schema}Enum(Enum):\n    elem${idx} = $schema(key='value')\n</code></pre> <p>This solution could introduce unintentional breaking changes when simply changing order of enum elements, unless enum elements were named with some extension keyword.</p> <p>It would work for scalar values</p> <pre><code>enum:\n- true\n- false\n- FileNotFound\n</code></pre> <p>=&gt;</p> <pre><code>class ${schema}Enum(Enum):\n    value_true = True\n    value_false = False\n    value_FileNotFound = 'FileNotFound'\n</code></pre> </li> </ol>"},{"location":"json-schema/#non-scalar-enum-values","title":"Non-scalar enum values","text":"<p>Non-scalar enum values don't have natural names, but a hash of stringified value could be used.</p> <p>Also creating an arbitrary number of objects, that might never be used will be expensive and wasteful, so factory methods could be used:</p> <pre><code>enum:\n-   id: 1\n    name: LoL\n    slug: league-of-legends\n</code></pre> <p>=&gt;</p> <pre><code>def value_5d9b08cdd67689d128f7c30f885f273c():\n    return CurrentVideogame(\n        id=1,\n        name='LoL',\n        slug='league-of-legends',\n    )\n</code></pre> <p>The problem with this solution is that the name changes when keys or any value changes, which may or may not be desirable from the user-developer perspective.</p>"},{"location":"json-schema/#scalar-constraints","title":"Scalar constraints","text":"<ol> <li> <p>Constraint keywords can be grouped by type (both numeric types together) and processed as such.</p> <pre><code>maximum: 10\nmaxLength: 10\nanyOf:\n- type: string\n- type: integer\n</code></pre> <p>=&gt;</p> <pre><code>anyOf:\n- type: string\n  maxLength: 10\n- type: integer\n  maximum: 10\n</code></pre> <p>=&gt;</p> <pre><code>Union[\n    Annotated[str, Field(max_length=10)],\n    Annotated[int, Field(ge=10)]\n]\n</code></pre> </li> <li> <p>There might be more than one element for a given type:</p> <pre><code>anyOf:\n- type: integer\n  maximum: 10\n- type: integer\n  minimum: 20\n</code></pre> <p>=&gt;</p> <pre><code>Union[\n    Annotated[int, Field(le=10)],\n    Annotated[int, Field(ge=20)],\n]\n</code></pre> </li> <li> <p>The above is different than this, which is a bottom type (no object can validate against it, since no number can be greater than 20 and smaller than 10):</p> <pre><code>type: integer\nmaximum: 10\nminimum: 20\n</code></pre> </li> <li> <p>As somewhat a special case, this schema is alright:</p> <pre><code>maximum: 10\nminimum: 20\n</code></pre> <p>=&gt;</p> <pre><code>str | bool | dict | list\n</code></pre> </li> <li> <p>allOf applies the most restrictive set of constraints.</p> <pre><code>allOf:\n- maximum: 10\n- maximum: 20\n</code></pre> <p>=&gt;</p> <pre><code>maximum: 10\n</code></pre> </li> </ol>"},{"location":"json-schema/#object-constraints","title":"Object constraints","text":"<ol> <li> <p>JSON type <code>object</code> could be mapped to <code>dict</code> or, with some limitations to <code>TypedDict</code> or a model in one of data modelling libraries like dataclasses, pydantic msgspec, etc. Here the choice falls on pydantic, which seems the most featured.</p> </li> <li> <p>In the most trivial (from python's perspective) case properties can be translated to instance fields in a model class:</p> <pre><code>additionalProperties: false\nproperties:\n  name:\n    type: string\n  required:\n  - name\n</code></pre> <p>=&gt;</p> <pre><code>class $name(BaseModel):\n  name: string\n</code></pre> </li> <li> <p>In case of empty schema, it's impossible to say anything about it's possible contents.</p> <p>It could be mapped as <code>dict</code> but then adding a property would cause an incompatible change in the python code. Instead, it can be translated to empty model class with <code>extra = 'allow'</code></p> <pre><code>{}\n</code></pre> <p>=&gt;</p> <pre><code>class $name(BaseModel):\n    model_config = pydantic.ConfigDict(\n        extra='allow'\n    )\n</code></pre> <p>The problem with this form is that there's no way to know what to do with the extra object values. Since an empty schema has the default:</p> <pre><code>additionalProperties: true\n</code></pre> <p>which is the same as</p> <pre><code>additionalProperties: {}\n</code></pre> <p>which means such a definition is indefinitely recursive. We could model it as a simple dict (in union with other types) or a common model class</p> <pre><code>class AnyObject(BaseModel):\n    model_config = pydantic.ConfigDict(\n        extra='allow'\n    )\n</code></pre> <p>but in either case adding a property (particularly a non-required property, which is a compatible change) leads to an incompatible change in the python model.</p> </li> </ol>"},{"location":"json-schema/#additionalproperties","title":"<code>additionalProperties</code>","text":"<p>The value is processed as a JSON Schema.</p> <ol> <li> <p><code>true</code></p> <p>Allows extra fields of any type. See above.</p> </li> <li> <p><code>false</code></p> <p>Forbids extra fields</p> <pre><code>class $name(BaseModel):\n    model_config = pydantic.ConfigDict(\n        extra='forbid'\n    )\n</code></pre> </li> <li> <p>A schema definition.</p> <p>Allows extra fields and, if a non-empty schema is used, generate type:</p> <pre><code>type: object\nadditionalProperties:\n    type: int\n</code></pre> <p>=&gt;</p> <pre><code>class $name(BaseModel):\n    model_config = pydantic.ConfigDict(\n        extra='allow'\n    )\n\n    __extra__: dict[str, int]\n</code></pre> </li> </ol>"},{"location":"json-schema/#writeonly-readonly-and-non-required-properties","title":"writeOnly, readOnly and non-required properties","text":"<p>Non-required means the same as optional in English, but <code>Optional</code> is a type in python, so avoiding it for clarity.</p> <p><code>writeOnly</code> and <code>readOnly</code> apply to schemas that are used in other schemas' properties. When one of the keywords is used, the property that schema describes only applies when the value is sent to or received from (respectively) the server, and should not be transferred in the other way.</p> <p>One option to implement it would be a class hierarchy - parent class with all properties, child class for request model and one for response model. This would get complicated with nested properties.</p> <p>Non-required properties are properties not listed in <code>required</code> list of the containing schema.</p> <p>writeOnly, readOnly and non-required can be made optional fields in python, even though readOnly and writeOnly properties may be required.</p> <p><pre><code>type: object\nproperties:\n   alpha:\n      type: string\n      readOnly: true\n   beta:\n      type: string\n      writeOnly: true\n   gamma:\n      type: string\n   required:\n   -  alpha\n   -  beta\n</code></pre> =&gt;</p> <pre><code>class $name:\n    alpha: str | None = None  # required in client response\n    beta:  str | None = None  # required in client request\n    gamma: str | None = None  # not required\n</code></pre>"},{"location":"json-schema/#arrays","title":"<code>array</code>s","text":"<p>Two keywords describe arrays</p>"},{"location":"json-schema/#anyof","title":"<code>anyOf</code>","text":"<p>When <code>anyOf</code> keyword is used, the instance validates as long as it validates against one of sub-schemas, while the validation results against other children schemas are ignored.</p> <p>For example, scalar constraints can be transformed to <code>Union</code> type</p> <pre><code>    type: integer\n    oneOf:\n    - maximum: 10\n    - minimum: 20\n\n=&gt;\n\n    Union[\n        Annotated[int, Field(ge=10)],\n        Annotated[int, Field(le=20)],\n    ]\n</code></pre>"},{"location":"json-schema/#oneof","title":"<code>oneOf</code>","text":"<ol> <li> <p>Per the specification <code>oneOf</code> keyword validates when the value validates against exactly one child schema.</p> <p>In practice it's not the case, and <code>oneOf</code> is used as type union, typically with disjoint sub-schemas, but sometimes erroneously with overlapping ones.</p> <p>For this reason it could be processed just like <code>anyOf</code>, although separately: values must validate against one of <code>oneOf</code> children and one of <code>anyOf</code> children.</p> </li> <li> <p>With only <code>type</code> constraint, <code>anyOf</code> and <code>oneOf</code> are equivalent, since any value can be of only one type:</p> <pre><code>oneOf:\n- type: integer\n- type: string\n\nanyOf:\n- type: integer\n- type: string\n</code></pre> <p>=&gt;</p> <pre><code>int | str\n</code></pre> </li> <li> <p>With more than one constraint for the same <code>type</code>, interpreting them (also for python) gets more complex</p> <pre><code>type: integer\noneOf:\n- maximum: 20\n- minimum: 10\n</code></pre> <p>is equivalent to:</p> <pre><code>type: integer\noneOf:\n- allOf:\n  - maximum: 20\n  # not minimum: 10\n  - maximum: 10\n    exclusiveMaximum: true\n- allOf:\n  - minimum: 10\n  # not maximum: 20\n  - minimum: 20\n    exclusiveMinimum: true\n</code></pre> <p>Since 10 &lt; 20, it reduces to:</p> <pre><code>type: integer\noneOf:\n# matches minimum: 10 but not maximum: 20\n- minimum: 20\n  exclusiveMinimum: true\n# matches maximum: 20 but not minimum: 10\n- maximum: 10\n  exclusiveMaximum: true\n</code></pre> </li> </ol>"},{"location":"json-schema/#allof","title":"<code>allOf</code>","text":"<ol> <li> <p>When processing <code>allOf</code> in schema, the goal is generating a schema that can be directly represented as a python model.</p> <p>The original schema must be replaced by a simplified equivalent.</p> </li> <li> <p>When <code>allOf</code> keyword is used, a value must validate against the schema that contains it as well as all children schemas in <code>allOf</code>.</p> <p>All schemas are of equal priority, and conflicting use of keywords makes it invalid for translating to a python model type.</p> <ol> <li> <p>The constraints in the top schema could be pushed down under <code>allOf</code> to get a homogenous <code>allOf</code> schema:</p> <pre><code>type: integer\nallOf:\n-   minimum: 10\n-   multipleOf: 2\n</code></pre> <p>=&gt;</p> <pre><code>allOf:\n-   type: integer\n-   minimum: 10\n-   multipleOf: 2\n</code></pre> </li> <li> <p>Constraints in <code>allOf</code> can be also pulled up to the top schema</p> <pre><code>allOf:\n-   type: integer\n-   minimum: 10\n-   multipleOf: 2\n</code></pre> <p>=&gt;</p> <pre><code>type: integer\nminimum: 10\nmultipleOf: 2\n</code></pre> <p>Constraint keywords behave differently when used with <code>allOf</code>. For example the most restrictive constraint win in case of scalar constraints, enums use set intersection but <code>oneOf</code> elements are deep-merged.</p> </li> </ol> <p>Because it doesn't matter whether constraints are in the parent schema or pushed down to a sub-schema, the paper assumes that constraints are pushed down to simplify the language.</p> </li> <li> <p>When <code>allOf</code> contains more than two sub-schemas, they can be processed sequentially</p> <pre><code>schema1 &amp; schema2 &amp; schema3 = (schema1 &amp; schema2) &amp; schema3\n</code></pre> </li> </ol>"},{"location":"json-schema/#allof-and-type","title":"<code>allOf</code> and <code>type</code>","text":"<p><code>allOf</code> applies a set intersection to <code>type</code></p> <pre><code># implied type: $any\nallOf:\n- type: integer\n</code></pre> <p>=&gt;</p> <pre><code>type: integer\nmaximum: 20\n</code></pre> <p>This is a bottom type:</p> <pre><code>allOf:\n- integer\n- string\n</code></pre>"},{"location":"json-schema/#allof-and-nullable","title":"<code>allOf</code> and <code>nullable</code>","text":"<p><code>null</code> value validates against a schema with defined <code>type</code> and <code>nullable: true</code>.</p> <p>Since <code>nullable</code> keyword applies only when <code>type</code> is defined, the <code>nullable</code> is <code>true</code> only when the type defined in that sub-schema is included in the resulting type and that type is defined in every sub-schema.</p> <pre><code>allOf:\n-   type: string\n    nullable: true\n    ...\n-   type: string\n    nullable: true\n    ...\n</code></pre>"},{"location":"json-schema/#allof-and-enum","title":"<code>allOf</code> and <code>enum</code>","text":"<p>If <code>enum</code> is in <code>allOf</code> sub-schemas, the output value is a set intersection of <code>enum</code> in all sub-schemas that have one.</p>"},{"location":"json-schema/#allof-and-scalar-constraints","title":"<code>allOf</code> and scalar constraints","text":"<ol> <li>When keywords don't repeat between sub-schemas, they can be simply merged..</li> <li>When the same keyword is used more than once, the more constraining value wins.</li> <li>When merging <code>maximum</code> and <code>minimum</code> values, <code>exclusiveMinimum</code> and <code>exclusiveMaximum</code> must be considered. If the keyword (<code>minmum</code> or <code>maximum</code>) has the same value, the one with <code>exclusive*: true</code> is more constraining.</li> </ol>"},{"location":"json-schema/#allof-and-object-constraints","title":"<code>allOf</code> and <code>object</code> constraints","text":"<ol> <li> <p>Determining named properties:</p> <ol> <li>Take all property names from all sub-schemas.</li> <li>If there are sub-schemas with <code>additionalProperties: false</code>, discard property names that match one of their property names.</li> </ol> </li> <li> <p>Determining named property schemas</p> <p>For each named property the resulting schema is calculated by merging</p> <ul> <li>named property schemas from all sub-schemas with that property, and</li> <li><code>additionalProperties</code> schemas from all sub-schemas that don't have the named property.</li> </ul> </li> </ol>"},{"location":"json-schema/#allof-and-array-constraints","title":"<code>allOf</code> and <code>array</code> constraints","text":"<ol> <li><code>additionalItems</code> is not supported in OpenAPI 3.0</li> <li> <p><code>items</code> schemas are merged as if they were direct children of <code>allOf</code>.</p> <pre><code>allOf:\n-   type: array\n    items:\n        maxLength: 10\n-   type: array\n    items:\n        maxLength: 20\n</code></pre> <p>=&gt;</p> <pre><code>type: array\nitems:\n    allOf:\n    -   maxLength: 10\n    -   maxLength: 20\n</code></pre> <p>=&gt;</p> <pre><code>type: array\nitems:\n    maxLength: 10\n</code></pre> </li> </ol>"},{"location":"json-schema/#nested-allof","title":"Nested <code>allOf</code>","text":"<p>Since schemas can be pushed down and pulled up around <code>allOf</code>, sub-schemas of nested <code>allOf</code> pulled up which results in flattening the schema.</p> <pre><code>allOf:\n-   allOf:\n    -   type: integer\n    -   minimum: 10\n-   multipleOf: 2\n</code></pre> <p>=&gt;</p> <pre><code>allOf:\n-   type: integer\n-   minimum: 10\n-   multipleOf: 2\n</code></pre>"},{"location":"json-schema/#allof-and-oneof-or-anyof","title":"<code>allOf</code> and (<code>oneOf</code> or <code>anyOf</code>)","text":"<p>When <code>oneOf</code> and/or <code>anyOf</code> keywords are present, the validated value must match one of sub-schemas of <code>anyOf</code> and one of sub-schemas of <code>oneOf</code>. A python model must be generated for each combination of constraints, meaning the schema needs to be a cartesian product of:</p> <ul> <li>the entire schema that's not part of <code>oneOf</code>/<code>anyOf</code></li> <li>sub-schemas under <code>oneOf</code> of each <code>allOf</code> sub-schemas</li> <li>sub-schemas under <code>anyOf</code> of each <code>allOf</code> sub-schemas</li> </ul>"},{"location":"json-schema/#not","title":"<code>not</code>","text":"<ol> <li> <p>The keyword can be interpreted as a reversal or, in some cases removal of constraints, depending on the constraint.</p> <pre><code>not:\n    minimum: 10\n</code></pre> <p>=&gt;</p> <pre><code>maximum: 20\nexclusiveMaximum: true\n</code></pre> </li> <li> <p>It can be used to exclude a set or a range of values:</p> <pre><code>maximum: 65535\nminimum: 1\nnot:\n    maximum: 65534\n    minimum: 65534\ntype: integer\n</code></pre> <p>=&gt;</p> <pre><code>type: integer\noneOf:\n-   minimum: 1\n    maximum: 65535\n-   minimum: 65534\n    maximum: 65534\n</code></pre> <p>=&gt;</p> <pre><code>Union[\n    Annotated[int, Field(ge=1, le=65533)],\n    Annotated[int, Field(ge=65535, le=65535)],\n]\n</code></pre> <p>Note: this is the only use of <code>not</code> I could find in apis.guru catalogue.</p> </li> </ol>"},{"location":"json-schema/#type-and-other-keywords","title":"<code>type</code> and other keywords","text":""},{"location":"json-schema/#type-and-enum","title":"<code>type</code> and <code>enum</code>","text":"<p>When <code>enum</code> and <code>type</code> are both used, any value present in <code>enum</code> but whose type is not present in <code>type</code> wouldn't validate. Similarly, any value of allowed type, but absent from enum wouldn't validate.</p> <p>Therefore <code>enum</code> keyword determines allowed types, and it's a set intersection of the two.</p>"},{"location":"json-schema/#nullable-types-and-enum","title":"<code>nullable</code> types and <code>enum</code>","text":"<p>When <code>enum</code> is defined and contains a <code>null</code> value, schema must also declare <code>type</code> and <code>nullable: true</code>.</p> <p>Otherwise <code>null</code> value doesn't validate against the default <code>type</code> or default <code>nullable</code></p>"},{"location":"json-schema/#type-and-constraints","title":"<code>type</code> and constraints","text":"<p>If <code>type</code> is defined, constraints for types not listed are discarded.</p> <p>The default <code>type</code> value (not defined) means all types are valid and all constraints are considered.</p>"},{"location":"json-schema/#type-and-anyof-or-oneof","title":"<code>type</code> and <code>anyOf</code> or <code>oneOf</code>","text":"<ol> <li> <p>When evaluating <code>type</code> with either <code>oneOf</code> or <code>anyOf</code>, the two are equivalent, since no JSON value can be of more than one type</p> <pre><code>anyOf:\n- type: integer\n- type: string\n</code></pre> <p>or</p> <pre><code>oneOf:\n- type: integer\n- type: string\n</code></pre> <p>=&gt;</p> <pre><code>int | str\n</code></pre> </li> </ol>"},{"location":"json-schema/#type-object-and-other-keywords","title":"<code>type: object</code> and other keywords","text":""},{"location":"json-schema/#object-and-oneofanyof","title":"<code>object</code> and <code>oneOf</code>/<code>anyOf</code>","text":"<p>The properties declared directly in the schema are always present (even if nullable, but excluding <code>writeOnly</code>/<code>readOnly</code>), but properties on <code>oneOf</code>/<code>anyOf</code> sub-schemas form optional groups, one of which must be present (even if elements of the group may be themselves optional).</p> <p>This suggests two possible solutions: 1. Create a class for each combination of properties. When OpenAPI properties or parameters are translated to python, represent such schema as a Union type. 1. Create a class for every element of <code>anyOf</code>/<code>oneOf</code> (use cartesian product if both are present) and add a synthetic Union field in the class representing the parent schema.</p> <p>Creating a parent class from the parent schema seems to only complicate things when both parent and sub-schemas define the same property.</p> <ol> <li> <p>Creating a <code>Union</code> type</p> <p>All constraints in the parent schema can be pushed down to <code>allOf</code>/<code>oneOf</code> so that it describes a <code>Union</code> type</p> <pre><code>components:\n    schemas:\n        mySchema:\n            type: object\n            properties\n                myProp:\n                    anyOf:\n                    -   type: string\n                    -   $ref: '#components/schemas/mySchema'\n</code></pre> <p>=&gt;</p> <pre><code>components:\n    schemas:\n        mySchema:\n            type: object\n            properties\n                myProp:\n                    anyOf:\n                    -   type: string\n                    -   $ref: mySchema\n</code></pre> <p>=&gt;</p> <pre><code>class mySchema:\n    myProp: str | mySchema\n</code></pre> </li> </ol>"},{"location":"json-schema/#type-object-allof-and-circular-references","title":"<code>type: object</code>, <code>allOf</code> and circular references","text":"<p>JSON Schema specification section 7 on <code>$ref</code> warns against scenario like this:</p> <pre><code>Alice:\n    properties:\n        myProp1:\n            type: string\n    allOf:\n    -   #/Bob\nBob:\n    properties:\n        myProp2:\n            type: string\n    allOf:\n    -   #/Alice\n</code></pre> <p>Actually oth schemas could be represented as the same class:</p> <pre><code>class Schema:\n    myProp1: str|None\n    myProp2: str|None\n</code></pre> <p>Instance of Schema class will validate against both schemas</p>"},{"location":"json-schema/#type-object-oneofanyof-and-allof","title":"<code>type: object</code>, <code>oneOf</code>/<code>anyOf</code> and <code>allOf</code>","text":"<p>Sub-schemas in <code>allOf/oneOf</code> and <code>allOf/anyOf</code> must validate separately and cannot be merged.</p> <pre><code>type: object\nproperties:\n    alpha:\n        type: integer\nadditionalProperties: false\nrequired:\n-   alpha\nallOf:\n-   oneOf:\n    -   properties:\n            alpha:\n                multipleOf: 2\n    -   properties:\n            alpha:\n                multipleOf: 3\n-   oneOf:\n    -   properties\n            alpha:\n                maximum: 20\n    -   properties:\n            alpha:\n                minimum: 10\n</code></pre> <p>Objects that validate would need validate against one of sub0schemas in the first child and one of sub-schemas in the second child. In this case the object would need a <code>int</code> field named 'alpha' that can be either divisible by 2 or 3 and at the same time either less or equal 10 or more or equal to 20.</p> <p>This really describes four possibilities:</p> <ol> <li>divisible by 2 and less or equal 20</li> <li>divisible by 2 and more or equal 10</li> <li>divisible by 3 and less or equal 20</li> <li>divisible by 3 and more or equal 10</li> </ol> <p>We can see wee need to restructure the schema by applying cartesian product and merging the inner allOf sub-schemas:</p> <pre><code>type: object\nproperties:\n    alpha:\n        type: integer\nadditionalProperties: false\nrequired:\n-   alpha\noneOf:\n-   properties:\n        alpha:\n            multipleOf: 2\n            maximum: 20\n-   properties:\n        alpha:\n            multipleOf: 2\n            minimum: 10\n-   properties:\n        alpha:\n            multipleOf: 3\n            maximum: 20\n-   properties:\n        alpha:\n            multipleOf: 3\n            minimum: 10\n</code></pre> <p>Also, properties get deep-merged:</p> <pre><code>type: object\nproperties:\n    alpha:\n        type: integer\nadditionalProperties: false\nrequired:\n-   alpha\nproperties:\n    alpha:\n        oneOf:\n        -   multipleOf: 2\n            maximum: 20\n        -   multipleOf: 2\n            minimum: 10\n        -   multipleOf: 3\n            maximum: 20\n        -   multipleOf: 3\n            minimum: 10\n</code></pre> <p>Now we can see a simple python class like this:</p> <pre><code>class $name:\n    alpha: Union[\n        Annotated[int, Field()]\n        Annotated[int, Field()]\n        Annotated[int, Field()]\n        Annotated[int, Field()]\n    ]\n</code></pre>"},{"location":"json-schema/#conflicting-schemas","title":"Conflicting schemas","text":"<ol> <li> <p>There are many ways of declaring schemas that no value could validate. Such schemas aren't invalid, but the part describing a single type the the keywords apply to, must be discarded.</p> <pre><code>minimum: 20\nmaximum: 10\n</code></pre> <p>=&gt;</p> <pre><code>oneOf:\n-   type: boolean\n-   type: string\n-   type: object\n-   type: array\n</code></pre> <p>but this schema never validates, so can't be translated to a type:</p> <pre><code>type: integer\nminimum: 20\nmaximum: 10\n</code></pre> </li> <li> <p>Conflicting enum values</p> <p><code>enum</code> keyword applies to all types so a conflict here makes the schema impossible to translate into a type:`</p> <pre><code>allOf:\n-   enum: [\"red\"]\n-   enum: [\"green\"]\n</code></pre> </li> </ol>"},{"location":"json-schema/#annotations","title":"Annotations","text":"<p>Schemas could produce annotations (type hints) and python types or type aliases (type aliases are not currently implemented).</p> <p>Whenever a schema is used, in an object property, or in case of OpenAPI, operation parameter, request or response body, in python an annotation is used.</p> <pre><code>Alice:\n    properties:\n        bob:\n            type: object\n            properties:\n                prop1:\n                    type: str\n</code></pre> <pre><code>class Alice(ModelBase):\n    bob: bob\n</code></pre> <p>But in order for <code>bob</code> to be valid, it also needs to be defined:</p> <pre><code>class bob\n    prop1: str\n</code></pre> <p>Scalar schemas could produce type aliases, but currently are used inline.</p> <pre><code>Alice:\n    type: object\n    properties:\n        prop1:\n            type: integer\n            maximum: 20\n</code></pre> <pre><code>class Alice:\n    prop1: Annotated[int, Le(20)]\n</code></pre>"},{"location":"json-schema/#generic-types","title":"Generic types","text":"<ol> <li>JSON Schema only supports generic arrays and maps:</li> </ol> <pre><code>sequence:\n  type: array\n  items:\n    type: string\nmap:\n  type: object\n  additionalProperties:\n    type: number\n</code></pre> <p>=&gt;</p> <pre><code>sequence: list[str]\nmap: dict[float]\n</code></pre> <p>There's no way of directly representing a generic python class:</p> <pre><code>class Envelope[T]:\n    id: uuid.UUID\n    payload: T\n\n\nclass Customer:\n    ...\n\n\ndata: Envelope[Customer]\n</code></pre> <p>can only be represented as concretised schemas:</p> <pre><code>Customer:\n   type: object\n\nEnvelope:\n   type: object\n   properties:\n      id:\n         type: string\n         format: uuid\n      payload:\n         type: object\n\nCustomerEnvelope:\n   allOf:\n   - $ref: '#/schemas/Envelope'\n   - properties:\n        payload:\n           $ref: '#/schemas/Customer'\n</code></pre>"},{"location":"json-schema/#references","title":"References","text":"<ol> <li>https://apis.guru/ - a directory of OpenAPI/swagger descriptions.</li> <li>https://www.learnjsonschema.com/2019-09/ - an extended explanation of JSON Schema keywords. Wrong version, but close enough.</li> </ol>"},{"location":"openapi/","title":"OpenAPI","text":"<p>OpenAPI compatibility</p> <ul> <li>\u2705 <code>openapi</code>: validated (3.0.* accepted)</li> <li><code>info</code><ul> <li>\u274c <code>license</code>: N/A; it's up to the user to verify the accepted use.</li> <li>\ud83d\uddd3\ufe0f <code>title</code> and other fields: planned as part of project readme</li> </ul> </li> <li>\ud83d\uddd3\ufe0f <code>externalDocs</code>: planned as part of the project readme</li> <li>\u2705 <code>servers</code>: first server is used<ul> <li>\u2705 <code>url</code>: used as the base URL</li> <li>\u2705 <code>variables</code>: default values are used to evaluate the server URL</li> </ul> </li> <li>\u2705 <code>security</code>: implemented</li> <li>\u274c <code>tags</code>: ignored</li> <li><code>components</code><ul> <li>\u2705 <code>schemas</code>:<ul> <li>\ud83d\uddd3\ufe0f <code>title</code>: planned as part of class docstr</li> <li><code>type</code><ul> <li>\u2705 [no value]: implemented as <code>pydantic.JsonValue</code></li> <li>\u26a0\ufe0f caveat: it which includes <code>None</code></li> <li>\u2705 <code>object</code>: implemented as pydantic model</li> <li>\u2705 <code>array</code>: implemented as list</li> <li>\u2705 <code>string</code>, <code>integer</code>, <code>number</code>, <code>boolean</code>: implemented as <code>str</code>, <code>int</code>, <code>float</code> and <code>bool</code></li> </ul> </li> <li>\u26a0\ufe0f <code>format</code>: Implemented for string types: <code>uuid</code>, <code>date</code>, <code>date-time</code>, <code>time</code> and <code>decimal</code></li> <li>\u2705 assertion keywords: as supported by annotated-types</li> <li>\u2705 <code>allOf</code>: implemented</li> <li>\u2705 <code>anyOf</code>: implemented as union</li> <li>\u26a0\ufe0f <code>oneOf</code>: treated as <code>anyOf</code> and implemented as <code>Union</code></li> <li>\ud83d\uddd3\ufe0f <code>not</code>: planned</li> <li>\u2705 <code>required</code>: non-required properties are turned to <code>Union[None, $type]</code></li> <li><code>additionalProperties</code>:</li> <li>\u2705 boolean: supported as pydantic <code>extra: 'allow'</code> or <code>'forbid'</code></li> <li>\ud83d\uddd3\ufe0f schema: planned as either a <code>Mapping</code> type or a <code>__pydantic_extra__</code> field</li> <li>\ud83d\udd0d <code>enum</code>: ignored; might be implemented for simple types as <code>Literal</code></li> <li>\ud83d\udcc4 <code>description</code>: planned as part of docstr</li> <li>\u2705 <code>default</code>: if present, the property type turned to <code>Union[None, $type]</code> and has default value <code>None</code></li> <li>\ud83d\udd0d caveat: default values are not to be sent between Web API client and server, instead they are implied by the receiving side. Lapidary could potentially implement generating default values for some cases but they don't necessary need to validate against the schema.</li> <li>\u2705 <code>nullable</code>: if true, the property type is turned to <code>Union[None, $type]</code></li> <li>\u2705 <code>readOnly</code> &amp; <code>writeOnly</code>: if either is true, the property type is turned to <code>Union[None, $type]</code> and has default value <code>None</code>; planned as part of docstr<ul> <li>\u26a0\ufe0f caveat: readOnly properties are only to be sent to API server, and writeOnly only to be received by the client. A property might be both required one way, and invalid the other way, which could not be directly represented in Python, except with two or three classes for every schema.</li> </ul> </li> <li>\ud83d\udcc4 <code>discriminator</code>: planed for use with pydantic discriminated unions</li> <li>\ud83d\udd0d <code>example</code>: might be used as part of docstr</li> <li>\ud83d\uddd3\ufe0f <code>externalDocs</code>: planned as part of docstr</li> <li>\ud83d\uddd3\ufe0f <code>deprecated</code>: planned</li> <li>\u274c <code>xml</code>: ignored, currently not planned</li> </ul> </li> <li><code>responses</code><ul> <li>\ud83d\uddd3\ufe0f <code>description</code>: planned as part of docstr</li> <li>\u2705 <code>headers</code>: if present, used as fields in the response envelope class</li> <li>\u2705 <code>content</code>: implemented; used as operation method return type, and a way to resolve model type for a response</li> <li>\ud83d\udd0d <code>links</code>: ignored; might be used to generate methods in the response envelope</li> </ul> </li> <li>\u2705 <code>parameters</code>: used in-line in operations</li> <li>\ud83d\udd0d <code>examples</code>: currently ignored</li> <li><code>requestBodies</code><ul> <li>\ud83d\uddd3\ufe0f <code>description</code>: planned as part of docstr</li> <li>\u2705 <code>content</code>: implemented</li> <li>\ud83d\uddd3\ufe0f <code>required</code>: planned</li> </ul> </li> <li>\u2705 <code>headers</code>: implemented</li> <li>\u26a0\ufe0f <code>securitySchemes</code>: implemented with httpx_auth<ul> <li>\u274c <code>refreshUrl</code>: not supported</li> </ul> </li> <li>\ud83d\uddd3\ufe0f <code>links</code>: planned</li> <li>\ud83d\uddd3\ufe0f <code>callbacks</code>: only planning to generate models from referenced schemas</li> </ul> </li> <li><code>paths</code>: \ud83d\uddd3\ufe0f planned as keys in a TypedDict<ul> <li>operations: \u2705 mapped to operation methods<ul> <li><code>operationId</code>: \u2705 used as method name</li> <li>\ud83d\uddd3\ufe0f <code>summary</code>, <code>description</code>: planned as parts of docstr</li> <li>\u274c <code>servers</code>: ignored</li> <li><code>parameters</code><ul> <li>\u2705 <code>name</code>: OpenAPI parameter names are not unique and might contain characters invalid for python names, therefore they're escaped and suffix-hungarian notation is used to distinguish between cookie, header, path and query parameters</li> <li>\u2705 <code>in</code>: implemented, suffix-hungarian notation is used to separate parameters</li> <li>\u2705 <code>required</code>: non-required parameters are optional with default value <code>None</code></li> <li>\ud83d\uddd3\ufe0f <code>deprecated</code>: planned</li> <li>\ud83d\uddd3\ufe0f <code>allowEmptyValue</code>: planned</li> <li>\ud83d\uddd3\ufe0f <code>content</code>: key: planned, value: processed as schema</li> <li>\u26a0\ufe0f <code>style</code>: partially implemented</li> <li>\ud83d\uddd3\ufe0f <code>allowReserved</code>: planned</li> <li>\u2705 <code>schema</code>: implemented</li> <li>\ud83d\udd0d <code>example</code> &amp; <code>examples</code>: considered</li> </ul> </li> </ul> </li> </ul> </li> </ul>"}]}