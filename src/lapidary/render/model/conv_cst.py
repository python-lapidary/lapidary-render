from collections.abc import Callable, Iterable, Iterator, Sequence
from typing import cast

import asyncclick
import libcst as cst

from . import openapi, python

MODULE_HEADER: Sequence[cst.EmptyLine] = (
    cst.EmptyLine(
        comment=cst.Comment('# This file is automatically @generated by Lapidary and should not be changed by hand.')
    ),
    cst.EmptyLine(),
)

DBL_EMPTY_LINE: Sequence[cst.EmptyLine] = (cst.EmptyLine(), cst.EmptyLine())


def mk_name(*parts: str) -> cst.Name | cst.Attribute:
    result: cst.Name | cst.Attribute = cst.Name(parts[0])
    for elem in parts[1:]:
        result = cst.Attribute(value=result, attr=cst.Name(elem))
    return result


def mk_raw_str_literal(value: str) -> cst.SimpleString:
    return cst.SimpleString(f"r'{value}'")


def str_literal(value: str) -> cst.SimpleString:
    return cst.SimpleString(f"'{value}'")


def mk_literal(value: str | int | float) -> cst.BaseExpression:
    if isinstance(value, str):
        return str_literal(value)
    elif isinstance(value, int):
        typ = cst.Integer
    elif isinstance(value, float):
        typ = cst.Float
    else:
        raise TypeError(value, type(value))
    if value < 0:
        negate = True
        value = -value
    else:
        negate = False
    node = typ(str(value))
    if negate:
        node = cst.UnaryOperation(cst.Minus(), node)
    return node


def mk_schema_module(model: python.SchemaModule) -> cst.Module:
    return cst.Module(
        header=MODULE_HEADER,
        body=[
            FUTURE_ANNOTATIONS,
            *mk_imports(model),
            *(
                mk_class_def(
                    class_name=class_model.name,
                    body=list(mk_schema_class_body(class_model)),
                    parent=mk_name('lapidary', 'runtime', 'ModelBase'),
                )
                for class_model in model.body
            ),
        ],
    )


def mk_class_def(
    class_name: str,
    body: Sequence[cst.SimpleStatementLine | cst.BaseCompoundStatement],
    parent: cst.Attribute | cst.Name | None = None,
) -> cst.ClassDef:
    return cst.ClassDef(
        name=cst.Name(class_name),
        bases=[cst.Arg(parent)] if parent else (),
        body=cst.IndentedBlock(body=body),
        leading_lines=DBL_EMPTY_LINE,
    )


def mk_call(
    fn_name: cst.Name | str | cst.Attribute,
    args: Sequence[cst.BaseExpression | cst.Arg] = (),
    indent: int | Callable = 1,
) -> cst.Call:
    indenter = mk_indent_factory(len(args), indent) if isinstance(indent, int) else indent
    args_: list[cst.Arg] = []
    for idx, arg in enumerate(args):
        if isinstance(arg, cst.Arg):
            arg_ = arg
        else:
            arg_ = cst.Arg(arg)

        if arg_.keyword:
            arg_ = arg_.with_changes(
                equal=cst.AssignEqual(
                    whitespace_before=cst.SimpleWhitespace(''), whitespace_after=cst.SimpleWhitespace('')
                )
            )
        args_.append(
            arg_.with_changes(
                comma=cst.Comma(whitespace_after=indenter(idx)),
            )
        )
    return cst.Call(
        cst.Name(fn_name) if isinstance(fn_name, str) else fn_name,
        args_,
        whitespace_before_args=indenter(-1),
    )


def mk_schema_class_body(model: python.SchemaClass) -> Iterable[cst.SimpleStatementLine | cst.BaseCompoundStatement]:
    if not model.fields and model.allow_extra:
        yield cst.SimpleStatementLine(body=[cst.Pass()])
        return

    yield from (mk_model_class_field_stmt(field) for field in model.fields)

    if not model.allow_extra:
        yield cst.SimpleStatementLine(
            leading_lines=[cst.EmptyLine()],
            body=[
                cst.Assign(
                    targets=[cst.AssignTarget(cst.Name('model_config'))],
                    value=mk_call(
                        mk_name('pydantic', 'ConfigDict'),
                        [
                            cst.Arg(
                                keyword=cst.Name('extra'),
                                value=cst.SimpleString("'forbid'"),
                            )
                        ],
                    ),
                )
            ],
        )


def mk_simple_type_name(typ: python.NameRef) -> cst.Name | cst.Attribute:
    # python can't decide on NoneType module
    # https://github.com/python/cpython/issues/128197
    if typ.name == 'NoneType':
        assert typ.module != 'builtins'
        if typ.module == 'types':
            return mk_name('None')

    if typ.module == 'builtins':
        return cst.Name(typ.name)
    else:
        parts = typ.module.split('.')
        return mk_name(*parts, typ.name)


def mk_annotated_type(
    typ: python.AnnotatedType,
    alias: str | None = None,
    metadata: Sequence[cst.Name | cst.Attribute | cst.Call] = (),
    indent: int = 1,
) -> cst.Name | cst.Attribute | cst.Subscript:
    result: cst.Name | cst.Attribute | cst.Subscript = mk_simple_type_name(typ.typ)
    if typ.generic_args:
        result = mk_parametrized_type(
            result, [mk_annotated_type(arg, indent=indent + 1) for arg in typ.generic_args], indent + 1
        )

    constraints = list(typ.num_constraints())
    all_metadata = [
        *metadata,
        *(mk_call(mk_simple_type_name(name), [mk_literal(value)]) for name, value in constraints),
    ]

    field_args = {}
    if typ.pattern:
        field_args['pattern'] = mk_raw_str_literal(typ.pattern)
    if alias:
        field_args['alias'] = str_literal(alias)
    if field_args:
        all_metadata.append(
            mk_call(
                mk_name('pydantic', 'Field'),
                [cst.Arg(keyword=cst.Name(key), value=value) for key, value in field_args.items()],
            )
        )

    if not all_metadata:
        return result

    return mk_parametrized_type(mk_name('typing', 'Annotated'), [result, *all_metadata], indent + 1)


def mk_model_class_field_stmt(model: python.AnnotatedVariable) -> cst.SimpleStatementLine:
    return cst.SimpleStatementLine(
        body=[
            cst.AnnAssign(
                target=cst.Name(model.name),
                annotation=cst.Annotation(
                    mk_annotated_type(
                        model.typ,
                        model.alias,
                    )
                ),
                value=cst.Name('None') if not model.required else None,
            )
        ],
        leading_lines=[cst.EmptyLine()],
    )


def mk_parametrized_type(
    typ: cst.Name | cst.Attribute,
    args: Sequence[cst.BaseExpression],
    indent=1,
) -> cst.Name | cst.Attribute | cst.Subscript:
    if not args:
        return typ

    else:
        indenter = mk_indent_factory(len(args), indent)
        elements = [
            cst.SubscriptElement(cst.Index(arg), cst.Comma(whitespace_after=indenter(idx)))
            for idx, arg in enumerate(args)
        ]
        return cst.Subscript(
            value=typ,
            lbracket=cst.LeftSquareBracket(indenter(-1)),
            slice=elements,
        )


def mk_indent_factory(
    items_len: int, depth: int, break_threshold=2
) -> Callable[[int], cst.BaseParenthesizableWhitespace]:
    do_indent = items_len >= break_threshold
    if do_indent:

        def mk_indentation(idx: int) -> cst.BaseParenthesizableWhitespace:
            last_item = idx == items_len - 1
            return cst.ParenthesizedWhitespace(
                first_line=cst.TrailingWhitespace(newline=cst.Newline()),
                last_line=cst.SimpleWhitespace(' ' * 4 * (depth - (1 if last_item else 0))),
                indent=True,
            )

        return mk_indentation
    else:

        def mk_indentation(_: int) -> cst.SimpleWhitespace:  # type: ignore[misc]
            return cst.SimpleWhitespace('')

        return mk_indentation


def mk_function(
    *,
    decorators: Iterable[cst.Name | cst.Attribute | cst.Call] = (),
    name: str,
    params: Iterable[cst.Param] = (),
    params_kwonly: Sequence[cst.Param] = (),
    param_kwargs: cst.Param | None = None,
    body: Iterable[cst.BaseStatement] = (cst.SimpleStatementLine(body=[cst.Pass()]),),
    returns: cst.Name | cst.Attribute | cst.Subscript | None = None,
    method: bool = False,
    async_: bool = False,
    indent=1,
) -> cst.FunctionDef:
    param_list = list(params)
    if method:
        param_list.insert(0, cst.Param(cst.Name('self'), cst.Annotation(mk_name('typing', 'Self'))))

    kwonly_start_idx = len(param_list)
    num_params = kwonly_start_idx + len(params_kwonly) + (1 if param_kwargs else 0)
    indent_factory = mk_indent_factory(num_params, indent, 1)
    return cst.FunctionDef(
        leading_lines=[cst.EmptyLine()],
        decorators=[cst.Decorator(decorator) for decorator in decorators],
        name=cst.Name(name),
        asynchronous=cst.Asynchronous() if async_ else None,
        params=cst.Parameters(
            [
                param.with_changes(comma=cst.Comma(whitespace_after=indent_factory(idx)))
                for idx, param in enumerate(param_list)
            ],
            kwonly_params=[
                param.with_changes(comma=cst.Comma(whitespace_after=indent_factory(idx + kwonly_start_idx)))
                for idx, param in enumerate(params_kwonly)
            ],
            star_kwarg=param_kwargs.with_changes(comma=cst.Comma(whitespace_after=indent_factory(num_params - 1)))
            if param_kwargs
            else None,
        ),
        body=cst.IndentedBlock(list(body)),
        returns=cst.Annotation(returns) if returns else None,
        whitespace_before_params=indent_factory(-1),
    )


def mk_in_annotation(model: python.Parameter, indent: int) -> cst.Attribute | cst.Call:
    in_args = []
    if model.alias:
        in_args.append(str_literal(model.alias))
    if model.style:
        in_args.append(cst.Arg(keyword=cst.Name('style'), value=mk_name('lapidary', 'runtime', model.style.value)))
    in_ = mk_name('lapidary', 'runtime', model.in_)
    return mk_call(in_, in_args, indent) if in_args else in_


def mk_operation_params(operation: python.OperationFunction) -> Iterator[cst.Param]:
    for param in operation.params:
        yield cst.Param(
            cst.Name(param.name),
            cst.Annotation(mk_annotated_type(param.typ, metadata=[mk_in_annotation(param, 1)])),
            default=cst.Name('None') if not param.required else None,
        )


def mk_client_init_fn(model: python.ClientInit) -> cst.FunctionDef:
    name_base_url = cst.Name('base_url')
    name_kwargs = cst.Name('kwargs')
    args = [cst.Arg(keyword=name_base_url, value=name_base_url), cst.Arg(star='**', value=name_kwargs)]
    if model.security:
        args.insert(0, cst.Arg(keyword=cst.Name('security'), value=mk_security_requirements_expr(model.security, 2)))

    return mk_function(
        name='__init__',
        params=[cst.Param(cst.Name('self'))],
        params_kwonly=[
            cst.Param(
                name_base_url,
                cst.Annotation(cst.Name('str')),
                default=str_literal(model.base_url) if model.base_url else None,
            )
        ],
        param_kwargs=cst.Param(name_kwargs),
        returns=cst.Name('None'),
        body=[
            cst.SimpleStatementLine(
                [
                    cst.Expr(
                        mk_call(
                            cst.Attribute(
                                mk_call('super'),
                                cst.Name('__init__'),
                            ),
                            args,
                        )
                    )
                ]
            )
        ],
    )


def mk_security_requirements_expr(reqs: python.SecurityRequirements, indent=1) -> cst.BaseExpression:
    indenter = mk_indent_factory(len(reqs), indent)
    return cst.Tuple(
        [
            cst.Element(
                cst.Dict(
                    [
                        cst.DictElement(str_literal(name_), cst.Tuple([cst.Element(str_literal(arg)) for arg in args]))
                        for name_, args in item.items()
                    ]
                ),
                cst.Comma(whitespace_after=indenter(idx)),
            )
            for idx, item in enumerate(reqs)
        ],
        lpar=[
            cst.LeftParen(
                whitespace_after=indenter(-1),
            ),
        ],
    )


def mk_body_annotation(mime_map: python.MimeMap, indent: int) -> cst.Call:
    indenter = mk_indent_factory(len(mime_map), indent, break_threshold=1)
    return mk_call(
        mk_name('lapidary', 'runtime', 'Body'),
        [
            cst.Dict(
                [
                    cst.DictElement(
                        str_literal(mime),
                        mk_annotated_type(typ, indent=indent),
                        comma=cst.Comma(whitespace_after=indenter(idx)),
                    )
                    for idx, (mime, typ) in enumerate(mime_map.items())
                ],
                lbrace=cst.LeftCurlyBrace(indenter(-1)),
            )
        ],
        6,
    )


def mk_response(response: python.Response) -> cst.Call:
    args = [mk_body_annotation(response.content, 5)]
    if response.headers_type != python.NoneMetaType:
        args.append(mk_annotated_type(response.headers_type))
    return mk_call(mk_name('lapidary', 'runtime', 'Response'), args, mk_indent_factory(len(args), 4, 1))


def mk_operation_method(operation: python.OperationFunction) -> cst.FunctionDef:
    decorator_args = [
        cst.Arg(str_literal(operation.path)),
    ]
    if operation.security is not None:
        decorator_args.append(
            cst.Arg(
                keyword=mk_name('security'),
                value=mk_security_requirements_expr(operation.security, 2),
            )
        )
    decorator = mk_call(mk_name('lapidary', 'runtime', operation.method), args=decorator_args)

    indenter = mk_indent_factory(len(operation.responses), 3, 1)
    responses = mk_call(
        mk_name('lapidary', 'runtime', 'Responses'),
        [
            cst.Dict(
                [
                    cst.DictElement(
                        str_literal(status_code), mk_response(response), comma=cst.Comma(whitespace_after=indenter(idx))
                    )
                    for idx, (status_code, response) in enumerate(operation.responses.items())
                ],
                lbrace=cst.LeftCurlyBrace(indenter(-1)),
            )
        ],
    )

    params = []
    if operation.request_body:
        params.append(
            cst.Param(
                cst.Name('body'),
                cst.Annotation(
                    mk_annotated_type(
                        operation.request_body_type, metadata=[mk_body_annotation(operation.request_body, 3)]
                    )
                ),
            )
        )

    return mk_function(
        name=operation.name,
        params=params,
        params_kwonly=list(mk_operation_params(operation)),
        returns=mk_annotated_type(operation.return_type, metadata=[responses]),
        decorators=[decorator],
        method=True,
        async_=True,
    )


def mk_client_module(module: python.ClientModule) -> cst.Module:
    body = [mk_client_init_fn(module.body.init_method)]
    with asyncclick.progressbar(module.body.methods, label='Rendering operations', show_eta=True) as bar:
        for operation in module.body.methods:
            bar.update(1, operation)
            body.append(mk_operation_method(operation))
    return cst.Module(
        header=MODULE_HEADER,
        body=[
            FUTURE_ANNOTATIONS,
            cst.EmptyLine(),
            cst.helpers.parse_template_statement("""
__all__ = (
    'ApiClient',
)"""),
            *mk_imports(module),
            mk_class_def(
                class_name='ApiClient',
                body=body,
                parent=mk_name('lapidary', 'runtime', 'ClientBase'),
            ),
        ],
    )


def mk_scope_slice(scopes: Iterable[str]) -> cst.Subscript:
    return mk_parametrized_type(mk_name('typing', 'Literal'), [str_literal(scope) for scope in scopes], 2)


def mk_security_fn(auth: python.Auth) -> cst.BaseStatement:
    fn_name = cst.Name(f'{auth.type}_{auth.python_name}')

    match auth:
        case python.ApiKeyAuth():
            return mk_auth_api_key(cast(python.ApiKeyAuth, auth), fn_name)
        case python.HttpBasicAuth():
            return mk_auth_http_basic(auth, fn_name)
        case python.HttpDigestAuth():
            return mk_auth_http_digest(auth, fn_name)
        case python.AuthorizationCodeOAuth2Flow():
            return mk_auth_oauth2_auth_code(cast(python.AuthorizationCodeOAuth2Flow, auth), fn_name)
        case python.ClientCredentialsOAuth2Flow():
            return mk_auth_oauth2_client_creds(cast(python.ClientCredentialsOAuth2Flow, auth), fn_name)
        case python.ImplicitOAuth2Flow():
            return mk_auth_oauth2_implicit(cast(python.ImplicitOAuth2Flow, auth), fn_name)
        case python.PasswordOAuth2Flow():
            return mk_auth_oauth2_passwd(cast(python.PasswordOAuth2Flow, auth), fn_name)
        case _:
            raise TypeError(auth, type(auth))


def mk_auth_oauth2_passwd(auth: python.PasswordOAuth2Flow, fn_name: cst.Name) -> cst.BaseStatement:
    return cst.helpers.parse_template_statement(
        """def {fn_name}(
    username: str,
    password: str,
    scope: typing.Union[
        collections.abc.Iterable[{scopes}],
        None
    ] = None,
    **kwargs,
) -> lapidary.runtime.NamedAuth:
    if scope is not None:
        kwargs['scope'] = ' '.join(scope)

    return {auth_name}, httpx_auth.OAuth2ResourceOwnerPasswordCredentials(
        token_url={token_url},
        username=username,
        password=password,
        **kwargs,
    )""",
        fn_name=fn_name,
        scopes=mk_scope_slice(auth.scopes.keys()),
        auth_name=str_literal(auth.name),
        token_url=str_literal(auth.token_url),
    )


def mk_auth_oauth2_implicit(auth: python.ImplicitOAuth2Flow, fn_name: cst.Name) -> cst.BaseStatement:
    return cst.helpers.parse_template_statement(
        """def {fn_name}(
    scope: typing.Union[
        collections.abc.Iterable[{scopes}],
        None
    ] = None,
    **kwargs,
) -> lapidary.runtime.NamedAuth:
    if scope is not None:
        kwargs['scope'] = ' '.join(scope)

    return {auth_name}, httpx_auth.OAuth2Implicit(
        authorization_url={authorization_url},
        **kwargs,
    )
""",
        fn_name=fn_name,
        scopes=mk_scope_slice(auth.scopes.keys()),
        auth_name=str_literal(auth.name),
        authorization_url=str_literal(auth.authorization_url),
    )


def mk_auth_oauth2_client_creds(auth: python.ClientCredentialsOAuth2Flow, fn_name: cst.Name) -> cst.BaseStatement:
    return cst.helpers.parse_template_statement(
        """def {fn_name}(
    client_id: str,
    client_secret: str,
    scope: typing.Union[
        collections.abc.Iterable[{scopes}],
        None
    ] = None,
    **kwargs,
) -> lapidary.runtime.NamedAuth:
    if scope is not None:
        kwargs['scope'] = ' '.join(scope)

    return {auth_name}, httpx_auth.OAuth2ClientCredentials(
        token_url={token_url},
        client_id=client_id,
        client_secret=client_secret,
        **kwargs,
    )""",
        fn_name=fn_name,
        scopes=mk_scope_slice(auth.scopes.keys()),
        auth_name=str_literal(auth.name),
        token_url=str_literal(auth.token_url),
    )


def mk_auth_oauth2_auth_code(auth: python.AuthorizationCodeOAuth2Flow, fn_name: cst.Name):
    return cst.helpers.parse_template_statement(
        """def {fn_name}(
    scope: typing.Union[
        collections.abc.Iterable[{scopes}],
        None
    ] = None,
    **kwargs,
) -> lapidary.runtime.NamedAuth:
    if scope is not None:
        kwargs['scope'] = ' '.join(scope)

    return {auth_name}, httpx_auth.OAuth2AuthorizationCode(
        authorization_url={authorization_url},
        token_url={token_url},
        **kwargs,
    )
""",
        fn_name=fn_name,
        scopes=mk_scope_slice(auth.scopes.keys()),
        auth_name=str_literal(auth.name),
        authorization_url=str_literal(auth.authorization_url),
        token_url=str_literal(auth.token_url),
    )


def mk_auth_http_digest(auth, fn_name):
    return cst.helpers.parse_template_statement(
        """def {fn_name}(
    user_name: str,
    password: str
) -> lapidary.runtime.NamedAuth:
    return {auth_name}, httpx.DigestAuth(
        username=user_name,
        password=password,
    )""",
        fn_name=fn_name,
        auth_name=str_literal(auth.name),
    )


def mk_auth_http_basic(auth, fn_name):
    return cst.helpers.parse_template_statement(
        """def {fn_name}(
    user_name: str,
    password: str
) -> lapidary.runtime.NamedAuth:
    return {auth_name}, httpx.BasicAuth(
        username=user_name,
        password=password,
    )""",
        fn_name=fn_name,
        auth_name=str_literal(auth.name),
    )


def mk_auth_api_key(auth: python.ApiKeyAuth, fn_name: cst.Name):
    param_name = auth.location.value + (
        '_parameter_name' if auth.location == openapi.ParameterLocation.QUERY else '_name'
    )
    return cst.helpers.parse_template_statement(
        """def {fn_name}(api_key: str) -> lapidary.runtime.NamedAuth:
    return {auth_name}, {auth_class}(
        api_key=api_key,
        {param_name}={auth_key},
    )""",
        fn_name=fn_name,
        auth_name=str_literal(auth.name),
        auth_class=mk_name('lapidary', 'runtime', 'auth', auth.location.value.capitalize() + 'ApiKey'),
        param_name=cst.Name(param_name),
        auth_key=str_literal(auth.key),
    )


def mk_security_module(module: python.SecurityModule) -> cst.Module:
    return cst.Module(
        header=MODULE_HEADER,
        body=[
            FUTURE_ANNOTATIONS,
            *(mk_imports(module)),
            cst.SimpleStatementLine([cst.Import([cst.ImportAlias(mk_name('lapidary', 'runtime', 'auth'))])]),
            *(mk_security_fn(auth).with_changes(leading_lines=DBL_EMPTY_LINE) for auth in module.body.values()),
        ],
    )


def mk_metadata_field(model: python.Parameter) -> cst.SimpleStatementLine:
    return cst.SimpleStatementLine(
        body=[
            cst.AnnAssign(
                target=cst.Name(model.name),
                annotation=cst.Annotation(
                    mk_annotated_type(
                        model.typ,
                        metadata=[mk_in_annotation(model, 1)],
                    )
                ),
                value=cst.Name('None') if not model.required else None,
            )
        ],
        leading_lines=[cst.EmptyLine()],
    )


def mk_metadata_class(model: python.MetadataModel) -> cst.ClassDef:
    return mk_class_def(
        model.name,
        [mk_metadata_field(field) for field in model.fields],
        mk_name('pydantic', 'BaseModel'),
    )


def mk_import(module: str) -> cst.Import:
    parts = module.split('.')
    return cst.Import([cst.ImportAlias(mk_name(*parts))])


def mk_imports(module: python.AbstractModule) -> Iterator[cst.SimpleStatementLine]:
    imports = [
        cst.SimpleStatementLine([cst.Import([cst.ImportAlias(mk_name('lapidary', 'runtime'))])], [cst.EmptyLine()]),
        cst.Import([cst.ImportAlias(cst.Name('pydantic'))]),
        cst.Import([cst.ImportAlias(cst.Name('typing_extensions'), cst.AsName(cst.Name('typing')))]),
        *(
            mk_import(mod_name)
            for mod_name in module.imports
            if mod_name not in ('pydantic', 'typing', 'lapidary.runtime')
        ),
    ]
    return (cst.SimpleStatementLine([imp]) if not isinstance(imp, cst.SimpleStatementLine) else imp for imp in imports)


def mk_metadata_module(module: python.MetadataModule) -> cst.Module:
    return cst.Module(
        header=MODULE_HEADER,
        body=[
            FUTURE_ANNOTATIONS,
            *mk_imports(module),
            *(mk_metadata_class(class_model) for class_model in module.body),
        ],
    )


MODULE_EMPTY = cst.Module(header=MODULE_HEADER, body=(), has_trailing_newline=False)

MODULE_ROOT = cst.Module(
    header=MODULE_HEADER, body=[cst.helpers.parse_template_statement('from .client import ApiClient')]
)

FUTURE_ANNOTATIONS = cst.ImportFrom(cst.Name('__future__'), [cst.ImportAlias(cst.Name('annotations'))])
